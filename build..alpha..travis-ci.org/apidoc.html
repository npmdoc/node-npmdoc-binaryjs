<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://binaryjs.com"

    >binaryjs (v0.2.1)</a>
</h1>
<h4>Binary realtime streaming made easy</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs">module binaryjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient">
            function <span class="apidocSignatureSpan">binaryjs.</span>BinaryClient
            <span class="apidocSignatureSpan">(socket, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryServer">
            function <span class="apidocSignatureSpan">binaryjs.</span>BinaryServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.createServer">
            function <span class="apidocSignatureSpan">binaryjs.</span>createServer
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">binaryjs.</span>BinaryClient.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">binaryjs.</span>BinaryServer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">binaryjs.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">binaryjs.</span>stream</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">binaryjs.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.BinaryClient">module binaryjs.BinaryClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.BinaryClient">
            function <span class="apidocSignatureSpan">binaryjs.</span>BinaryClient
            <span class="apidocSignatureSpan">(socket, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.super_">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.BinaryClient.prototype">module binaryjs.BinaryClient.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.prototype._receiveStream">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>_receiveStream
            <span class="apidocSignatureSpan">(streamId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.prototype.close">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.prototype.createStream">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>createStream
            <span class="apidocSignatureSpan">(meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.prototype.destroy">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryClient.prototype.send">
            function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>send
            <span class="apidocSignatureSpan">(data, meta)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.BinaryServer">module binaryjs.BinaryServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryServer.BinaryServer">
            function <span class="apidocSignatureSpan">binaryjs.</span>BinaryServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryServer.super_">
            function <span class="apidocSignatureSpan">binaryjs.BinaryServer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.BinaryServer.prototype">module binaryjs.BinaryServer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.BinaryServer.prototype.close">
            function <span class="apidocSignatureSpan">binaryjs.BinaryServer.prototype.</span>close
            <span class="apidocSignatureSpan">(code, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.client">module binaryjs.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.client.BinaryClient">
            function <span class="apidocSignatureSpan">binaryjs.client.</span>BinaryClient
            <span class="apidocSignatureSpan">(socket, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.stream">module binaryjs.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.stream.BinaryStream">
            function <span class="apidocSignatureSpan">binaryjs.stream.</span>BinaryStream
            <span class="apidocSignatureSpan">(socket, id, create, meta)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.binaryjs.util">module binaryjs.util</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">binaryjs.util.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.util.extend">
            function <span class="apidocSignatureSpan">binaryjs.util.</span>extend
            <span class="apidocSignatureSpan">(dest, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.util.inherits">
            function <span class="apidocSignatureSpan">binaryjs.util.</span>inherits
            <span class="apidocSignatureSpan">(ctor, superCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.util.pack">
            function <span class="apidocSignatureSpan">binaryjs.util.</span>pack
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.util.setZeroTimeout">
            function <span class="apidocSignatureSpan">binaryjs.util.</span>setZeroTimeout
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.binaryjs.util.unpack">
            function <span class="apidocSignatureSpan">binaryjs.util.</span>unpack
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs" id="apidoc.module.binaryjs">module binaryjs</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient" id="apidoc.element.binaryjs.BinaryClient">
        function <span class="apidocSignatureSpan">binaryjs.</span>BinaryClient
        <span class="apidocSignatureSpan">(socket, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryClient(socket, options) {
  if (!(this instanceof BinaryClient)) return new BinaryClient(socket, options);

  EventEmitter.call(this);

  var self = this;

  this._options = util.extend({
    chunkSize: 40960
  }, options);

  this.streams = {};

  if(typeof socket === &#x27;string&#x27;) {
    this._nextId = 0;
    this._socket = new WebSocket(socket);
  } else {
    // Use odd numbered ids for server originated streams
    this._nextId = 1;
    this._socket = socket;
  }

  this._socket.binaryType = &#x27;arraybuffer&#x27;;

  this._socket.addEventListener(&#x27;open&#x27;, function(){
    self.emit(&#x27;open&#x27;);
  });
  // if node
  this._socket.on(&#x27;drain&#x27;, function(){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onDrain();
    }
  });
  // end node
  this._socket.addEventListener(&#x27;error&#x27;, function(error){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onError(error);
    }
    self.emit(&#x27;error&#x27;, error);
  });
  this._socket.addEventListener(&#x27;close&#x27;, function(code, message){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onClose();
    }
    self.emit(&#x27;close&#x27;, code, message);
  });
  this._socket.addEventListener(&#x27;message&#x27;, function(data, flags){
    util.setZeroTimeout(function(){

      // Message format
      // [type, payload, bonus ]
      //
      // Reserved
      // [ 0  , X , X ]
      //
      //
      // New stream
      // [ 1  , Meta , new streamId ]
      //
      //
      // Data
      // [ 2  , Data , streamId ]
      //
      //
      // Pause
      // [ 3  , null , streamId ]
      //
      //
      // Resume
      // [ 4  , null , streamId ]
      //
      //
      // End
      // [ 5  , null , streamId ]
      //
      //
      // Close
      // [ 6  , null , streamId ]
      //

      data = data.data;

      try {
          data = util.unpack(data);
      } catch (ex) {
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received unparsable message: &#x27; + ex));
      }
      if (!(data instanceof Array))
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received non-array message&#x27;));
      if (data.length != 3)
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with wrong part count: &#x27; + data.length));
      if (&#x27;number&#x27; != typeof data[0])
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with non-number type: &#x27; + data[0]));

      switch(data[0]) {
        case 0:
          // Reserved
          break;
        case 1:
          var meta = data[1];
          var streamId = data[2];
          var binaryStream = self._receiveStream(streamId);
          self.emit(&#x27;stream&#x27;, binaryStream, meta);
          break;
        case 2:
          var payload = data[1];
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onData(payload);
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `data` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 3:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onPause();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `pause` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 4:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onResume();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `resume` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 5:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onEnd();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `end` message for u ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryServer" id="apidoc.element.binaryjs.BinaryServer">
        function <span class="apidocSignatureSpan">binaryjs.</span>BinaryServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryServer(options) {
  if (!(this instanceof BinaryServer)) return new BinaryServer(options);

  var self = this;

  options = util.extend({
    host: &#x27;0.0.0.0&#x27;,
    chunkSize: 40960
  }, options);

  this.clients = {};
  this._clientCounter = 0;


  if (options.server &#x26;&#x26; (options.server instanceof ws.Server)) {
    this._server  = options.server;
  } else {
    this._server  = new ws.Server(options);
  }

  this._server.on(&#x27;connection&#x27;, function(socket){
    var clientId = self._clientCounter;
    var binaryClient = new BinaryClient(socket, options);
    binaryClient.id = clientId;
    self.clients[clientId] = binaryClient;
    self._clientCounter++;
    binaryClient.on(&#x27;close&#x27;, function(){
      delete self.clients[clientId];
    });
    self.emit(&#x27;connection&#x27;, binaryClient);
  });
  this._server.on(&#x27;error&#x27;, function(error){
    self.emit(&#x27;error&#x27;, error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.createServer" id="apidoc.element.binaryjs.createServer">
        function <span class="apidocSignatureSpan">binaryjs.</span>createServer
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function (fn) {
  var server;

  return {
    listen : function(port, opts) {
      opts = opts || {};
      opts.port = port;

      var server = new BinaryServer(opts);
      server.on(&#x27;connection&#x27;, function(conn) {
        fn &#x26;&#x26; fn(conn.createStream());
      });

      return server;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.BinaryClient" id="apidoc.module.binaryjs.BinaryClient">module binaryjs.BinaryClient</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.BinaryClient" id="apidoc.element.binaryjs.BinaryClient.BinaryClient">
        function <span class="apidocSignatureSpan">binaryjs.</span>BinaryClient
        <span class="apidocSignatureSpan">(socket, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryClient(socket, options) {
  if (!(this instanceof BinaryClient)) return new BinaryClient(socket, options);

  EventEmitter.call(this);

  var self = this;

  this._options = util.extend({
    chunkSize: 40960
  }, options);

  this.streams = {};

  if(typeof socket === &#x27;string&#x27;) {
    this._nextId = 0;
    this._socket = new WebSocket(socket);
  } else {
    // Use odd numbered ids for server originated streams
    this._nextId = 1;
    this._socket = socket;
  }

  this._socket.binaryType = &#x27;arraybuffer&#x27;;

  this._socket.addEventListener(&#x27;open&#x27;, function(){
    self.emit(&#x27;open&#x27;);
  });
  // if node
  this._socket.on(&#x27;drain&#x27;, function(){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onDrain();
    }
  });
  // end node
  this._socket.addEventListener(&#x27;error&#x27;, function(error){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onError(error);
    }
    self.emit(&#x27;error&#x27;, error);
  });
  this._socket.addEventListener(&#x27;close&#x27;, function(code, message){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onClose();
    }
    self.emit(&#x27;close&#x27;, code, message);
  });
  this._socket.addEventListener(&#x27;message&#x27;, function(data, flags){
    util.setZeroTimeout(function(){

      // Message format
      // [type, payload, bonus ]
      //
      // Reserved
      // [ 0  , X , X ]
      //
      //
      // New stream
      // [ 1  , Meta , new streamId ]
      //
      //
      // Data
      // [ 2  , Data , streamId ]
      //
      //
      // Pause
      // [ 3  , null , streamId ]
      //
      //
      // Resume
      // [ 4  , null , streamId ]
      //
      //
      // End
      // [ 5  , null , streamId ]
      //
      //
      // Close
      // [ 6  , null , streamId ]
      //

      data = data.data;

      try {
          data = util.unpack(data);
      } catch (ex) {
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received unparsable message: &#x27; + ex));
      }
      if (!(data instanceof Array))
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received non-array message&#x27;));
      if (data.length != 3)
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with wrong part count: &#x27; + data.length));
      if (&#x27;number&#x27; != typeof data[0])
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with non-number type: &#x27; + data[0]));

      switch(data[0]) {
        case 0:
          // Reserved
          break;
        case 1:
          var meta = data[1];
          var streamId = data[2];
          var binaryStream = self._receiveStream(streamId);
          self.emit(&#x27;stream&#x27;, binaryStream, meta);
          break;
        case 2:
          var payload = data[1];
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onData(payload);
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `data` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 3:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onPause();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `pause` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 4:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onResume();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `resume` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 5:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onEnd();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `end` message for u ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.super_" id="apidoc.element.binaryjs.BinaryClient.super_">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.BinaryClient.prototype" id="apidoc.module.binaryjs.BinaryClient.prototype">module binaryjs.BinaryClient.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.prototype._receiveStream" id="apidoc.element.binaryjs.BinaryClient.prototype._receiveStream">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>_receiveStream
        <span class="apidocSignatureSpan">(streamId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_receiveStream = function (streamId){
  var self = this;
  var binaryStream = new BinaryStream(this._socket, streamId, false);
  binaryStream.on(&#x27;close&#x27;, function(){
    delete self.streams[streamId];
  });
  this.streams[streamId] = binaryStream;
  return binaryStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      switch(data[0]) {
case 0:
  // Reserved
  break;
case 1:
  var meta = data[1];
  var streamId = data[2];
  var binaryStream = self.<span class="apidocCodeKeywordSpan">_receiveStream</span>(streamId);
  self.emit(&#x27;stream&#x27;, binaryStream, meta);
  break;
case 2:
  var payload = data[1];
  var streamId = data[2];
  var binaryStream = self.streams[streamId];
  if(binaryStream) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.prototype.close" id="apidoc.element.binaryjs.BinaryClient.prototype.close">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
  this._socket.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete self.streams[streamId];
  });
  this.streams[streamId] = binaryStream;
  return binaryStream;
};

BinaryClient.prototype.close = BinaryClient.prototype.destroy = function() {
  this._socket.<span class="apidocCodeKeywordSpan">close</span>();
};

exports.BinaryClient = BinaryClient;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.prototype.createStream" id="apidoc.element.binaryjs.BinaryClient.prototype.createStream">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>createStream
        <span class="apidocSignatureSpan">(meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStream = function (meta){
  if(this._socket.readyState !== WebSocket.OPEN) {
    throw new Error(&#x27;Client is not yet connected or has closed&#x27;);
    return;
  }
  var self = this;
  var streamId = this._nextId;
  this._nextId += 2;
  var binaryStream = new BinaryStream(this._socket, streamId, true, meta);
  binaryStream.on(&#x27;close&#x27;, function(){
    delete self.streams[streamId];
  });
  this.streams[streamId] = binaryStream;
  return binaryStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
});
}

util.inherits(BinaryClient, EventEmitter);

BinaryClient.prototype.send = function(data, meta){
var stream = this.<span class="apidocCodeKeywordSpan">createStream</span>(meta);
if(data instanceof Stream) {
  data.pipe(stream);
} else if (util.isNode === true) {
  if(Buffer.isBuffer(data)) {
    (new BufferReadStream(data, {chunkSize: this._options.chunkSize})).pipe(stream);
  } else {
    stream.write(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.prototype.destroy" id="apidoc.element.binaryjs.BinaryClient.prototype.destroy">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  this._socket.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryClient.prototype.send" id="apidoc.element.binaryjs.BinaryClient.prototype.send">
        function <span class="apidocSignatureSpan">binaryjs.BinaryClient.prototype.</span>send
        <span class="apidocSignatureSpan">(data, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (data, meta){
  var stream = this.createStream(meta);
  if(data instanceof Stream) {
    data.pipe(stream);
  } else if (util.isNode === true) {
    if(Buffer.isBuffer(data)) {
      (new BufferReadStream(data, {chunkSize: this._options.chunkSize})).pipe(stream);
    } else {
      stream.write(data);
    }
  } else if (util.isNode !== true) {
    if(data.constructor == Blob || data.constructor == File) {
      (new BlobReadStream(data, {chunkSize: this._options.chunkSize})).pipe(stream);
    } else if (data.constructor == ArrayBuffer) {
      var blob;
      if(binaryFeatures.useArrayBufferView) {
        data = new Uint8Array(data);
      }
      if(binaryFeatures.useBlobBuilder) {
        var builder = new BlobBuilder();
        builder.append(data);
        blob = builder.getBlob()
      } else {
        blob = new Blob([data]);
      }
      (new BlobReadStream(blob, {chunkSize: this._options.chunkSize})).pipe(stream);
    } else if (typeof data === &#x27;object&#x27; &#x26;&#x26; &#x27;BYTES_PER_ELEMENT&#x27; in data) {
      var blob;
      if(!binaryFeatures.useArrayBufferView) {
        // Warn
        data = data.buffer;
      }
      if(binaryFeatures.useBlobBuilder) {
        var builder = new BlobBuilder();
        builder.append(data);
        blob = builder.getBlob()
      } else {
        blob = new Blob([data]);
      }
      (new BlobReadStream(blob, {chunkSize: this._options.chunkSize})).pipe(stream);
    } else {
      stream.write(data);
    }
  }
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

BinaryStream.prototype._write = function(code, data, bonus) {
if (this._socket.readyState !== this._socket.constructor.OPEN) {
  return false;
}
var message = util.pack([code, data, bonus]);
return this._socket.<span class="apidocCodeKeywordSpan">send</span>(message) !== false;
};

BinaryStream.prototype.write = function(data) {
if(this.writable) {
  var out = this._write(2, data, this.id);
  return !this.paused &#x26;&#x26; out;
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.BinaryServer" id="apidoc.module.binaryjs.BinaryServer">module binaryjs.BinaryServer</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.BinaryServer.BinaryServer" id="apidoc.element.binaryjs.BinaryServer.BinaryServer">
        function <span class="apidocSignatureSpan">binaryjs.</span>BinaryServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryServer(options) {
  if (!(this instanceof BinaryServer)) return new BinaryServer(options);

  var self = this;

  options = util.extend({
    host: &#x27;0.0.0.0&#x27;,
    chunkSize: 40960
  }, options);

  this.clients = {};
  this._clientCounter = 0;


  if (options.server &#x26;&#x26; (options.server instanceof ws.Server)) {
    this._server  = options.server;
  } else {
    this._server  = new ws.Server(options);
  }

  this._server.on(&#x27;connection&#x27;, function(socket){
    var clientId = self._clientCounter;
    var binaryClient = new BinaryClient(socket, options);
    binaryClient.id = clientId;
    self.clients[clientId] = binaryClient;
    self._clientCounter++;
    binaryClient.on(&#x27;close&#x27;, function(){
      delete self.clients[clientId];
    });
    self.emit(&#x27;connection&#x27;, binaryClient);
  });
  this._server.on(&#x27;error&#x27;, function(error){
    self.emit(&#x27;error&#x27;, error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.BinaryServer.super_" id="apidoc.element.binaryjs.BinaryServer.super_">
        function <span class="apidocSignatureSpan">binaryjs.BinaryServer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.BinaryServer.prototype" id="apidoc.module.binaryjs.BinaryServer.prototype">module binaryjs.BinaryServer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.BinaryServer.prototype.close" id="apidoc.element.binaryjs.BinaryServer.prototype.close">
        function <span class="apidocSignatureSpan">binaryjs.BinaryServer.prototype.</span>close
        <span class="apidocSignatureSpan">(code, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, message){
  this._server.close(code, message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete self.streams[streamId];
  });
  this.streams[streamId] = binaryStream;
  return binaryStream;
};

BinaryClient.prototype.close = BinaryClient.prototype.destroy = function() {
  this._socket.<span class="apidocCodeKeywordSpan">close</span>();
};

exports.BinaryClient = BinaryClient;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.client" id="apidoc.module.binaryjs.client">module binaryjs.client</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.client.BinaryClient" id="apidoc.element.binaryjs.client.BinaryClient">
        function <span class="apidocSignatureSpan">binaryjs.client.</span>BinaryClient
        <span class="apidocSignatureSpan">(socket, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryClient(socket, options) {
  if (!(this instanceof BinaryClient)) return new BinaryClient(socket, options);

  EventEmitter.call(this);

  var self = this;

  this._options = util.extend({
    chunkSize: 40960
  }, options);

  this.streams = {};

  if(typeof socket === &#x27;string&#x27;) {
    this._nextId = 0;
    this._socket = new WebSocket(socket);
  } else {
    // Use odd numbered ids for server originated streams
    this._nextId = 1;
    this._socket = socket;
  }

  this._socket.binaryType = &#x27;arraybuffer&#x27;;

  this._socket.addEventListener(&#x27;open&#x27;, function(){
    self.emit(&#x27;open&#x27;);
  });
  // if node
  this._socket.on(&#x27;drain&#x27;, function(){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onDrain();
    }
  });
  // end node
  this._socket.addEventListener(&#x27;error&#x27;, function(error){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onError(error);
    }
    self.emit(&#x27;error&#x27;, error);
  });
  this._socket.addEventListener(&#x27;close&#x27;, function(code, message){
    var ids = Object.keys(self.streams);
    for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
      self.streams[ids[i]]._onClose();
    }
    self.emit(&#x27;close&#x27;, code, message);
  });
  this._socket.addEventListener(&#x27;message&#x27;, function(data, flags){
    util.setZeroTimeout(function(){

      // Message format
      // [type, payload, bonus ]
      //
      // Reserved
      // [ 0  , X , X ]
      //
      //
      // New stream
      // [ 1  , Meta , new streamId ]
      //
      //
      // Data
      // [ 2  , Data , streamId ]
      //
      //
      // Pause
      // [ 3  , null , streamId ]
      //
      //
      // Resume
      // [ 4  , null , streamId ]
      //
      //
      // End
      // [ 5  , null , streamId ]
      //
      //
      // Close
      // [ 6  , null , streamId ]
      //

      data = data.data;

      try {
          data = util.unpack(data);
      } catch (ex) {
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received unparsable message: &#x27; + ex));
      }
      if (!(data instanceof Array))
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received non-array message&#x27;));
      if (data.length != 3)
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with wrong part count: &#x27; + data.length));
      if (&#x27;number&#x27; != typeof data[0])
          return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with non-number type: &#x27; + data[0]));

      switch(data[0]) {
        case 0:
          // Reserved
          break;
        case 1:
          var meta = data[1];
          var streamId = data[2];
          var binaryStream = self._receiveStream(streamId);
          self.emit(&#x27;stream&#x27;, binaryStream, meta);
          break;
        case 2:
          var payload = data[1];
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onData(payload);
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `data` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 3:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onPause();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `pause` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 4:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onResume();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `resume` message for unknown stream: &#x27; + streamId));
          }
          break;
        case 5:
          var streamId = data[2];
          var binaryStream = self.streams[streamId];
          if(binaryStream) {
            binaryStream._onEnd();
          } else {
            self.emit(&#x27;error&#x27;, new Error(&#x27;Received `end` message for u ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.stream" id="apidoc.module.binaryjs.stream">module binaryjs.stream</a></h1>


    <h2>
        <a href="#apidoc.element.binaryjs.stream.BinaryStream" id="apidoc.element.binaryjs.stream.BinaryStream">
        function <span class="apidocSignatureSpan">binaryjs.stream.</span>BinaryStream
        <span class="apidocSignatureSpan">(socket, id, create, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BinaryStream(socket, id, create, meta) {
  if (!(this instanceof BinaryStream)) return new BinaryStream(options);

  var self = this;

  Stream.call(this);


  this.id = id;
  this._socket = socket;

  this.writable = true;
  this.readable = true;
  this.paused = false;

  this._closed = false;
  this._ended = false;

  if(create) {
    // This is a stream we are creating
    this._write(1, meta, this.id);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.binaryjs.util" id="apidoc.module.binaryjs.util">module binaryjs.util</a></h1>




    <h2>
        <a href="#apidoc.element.binaryjs.util.extend" id="apidoc.element.binaryjs.util.extend">
        function <span class="apidocSignatureSpan">binaryjs.util.</span>extend
        <span class="apidocSignatureSpan">(dest, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (dest, source) {
  for(var key in source) {
    if(source.hasOwnProperty(key)) {
      dest[key] = source[key];
    }
  }
  return dest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function BinaryClient(socket, options) {
if (!(this instanceof BinaryClient)) return new BinaryClient(socket, options);

EventEmitter.call(this);

var self = this;

this._options = util.<span class="apidocCodeKeywordSpan">extend</span>({
  chunkSize: 40960
}, options);

this.streams = {};

if(typeof socket === &#x27;string&#x27;) {
  this._nextId = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.util.inherits" id="apidoc.element.binaryjs.util.inherits">
        function <span class="apidocSignatureSpan">binaryjs.util.</span>inherits
        <span class="apidocSignatureSpan">(ctor, superCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      default:
        self.emit(&#x27;error&#x27;, new Error(&#x27;Unrecognized message type received: &#x27; + data[0]));
    }
  });
});
}

util.<span class="apidocCodeKeywordSpan">inherits</span>(BinaryClient, EventEmitter);

BinaryClient.prototype.send = function(data, meta){
var stream = this.createStream(meta);
if(data instanceof Stream) {
  data.pipe(stream);
} else if (util.isNode === true) {
  if(Buffer.isBuffer(data)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.util.pack" id="apidoc.element.binaryjs.util.pack">
        function <span class="apidocSignatureSpan">binaryjs.util.</span>pack
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pack = function (data){
  var packer = new BinaryPack.Packer();
  var buffer = packer.pack(data);
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.emit(&#x27;drain&#x27;);
};

BinaryStream.prototype._write = function(code, data, bonus) {
if (this._socket.readyState !== this._socket.constructor.OPEN) {
  return false;
}
var message = util.<span class="apidocCodeKeywordSpan">pack</span>([code, data, bonus]);
return this._socket.send(message) !== false;
};

BinaryStream.prototype.write = function(data) {
if(this.writable) {
  var out = this._write(2, data, this.id);
  return !this.paused &#x26;&#x26; out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.util.setZeroTimeout" id="apidoc.element.binaryjs.util.setZeroTimeout">
        function <span class="apidocSignatureSpan">binaryjs.util.</span>setZeroTimeout
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ids = Object.keys(self.streams);
  for (var i = 0, ii = ids.length; i &#x3c; ii; i++) {
    self.streams[ids[i]]._onClose();
  }
  self.emit(&#x27;close&#x27;, code, message);
});
this._socket.addEventListener(&#x27;message&#x27;, function(data, flags){
  util.<span class="apidocCodeKeywordSpan">setZeroTimeout</span>(function(){

    // Message format
    // [type, payload, bonus ]
    //
    // Reserved
    // [ 0  , X , X ]
    //
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.binaryjs.util.unpack" id="apidoc.element.binaryjs.util.unpack">
        function <span class="apidocSignatureSpan">binaryjs.util.</span>unpack
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpack = function (data){
  var unpacker = new BinaryPack.Unpacker(data);
  return unpacker.unpack();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Close
// [ 6  , null , streamId ]
//

data = data.data;

try {
    data = util.<span class="apidocCodeKeywordSpan">unpack</span>(data);
} catch (ex) {
    return self.emit(&#x27;error&#x27;, new Error(&#x27;Received unparsable message: &#x27; + ex));
}
if (!(data instanceof Array))
    return self.emit(&#x27;error&#x27;, new Error(&#x27;Received non-array message&#x27;));
if (data.length != 3)
    return self.emit(&#x27;error&#x27;, new Error(&#x27;Received message with wrong part count: &#x27; + data.length));
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
